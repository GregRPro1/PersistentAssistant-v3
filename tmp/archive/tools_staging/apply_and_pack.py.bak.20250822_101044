# =============================================================================
# tools/apply_and_pack.py â€” supervisor-style (unkillable)
# - Works with or without args
# - None-safe (no .name/.basename on None)
# - ALWAYS produces a pack (OK or WARN or EMERGENCY)
# - Captures stdout+stderr of each sub-step into supervisor_log.txt
# Usage:
#   python tools/apply_and_pack.py [<target_path> <new_path> [label]]
# =============================================================================
from __future__ import annotations
import os, sys, time, shutil, subprocess, zipfile, pathlib, traceback

try:
    import pyperclip
except Exception:
    pyperclip = None

ROOT = pathlib.Path(__file__).resolve().parents[1]
TMP = ROOT / "tmp"
ARCHIVE = TMP / "archive"
FEEDBACK = TMP / "feedback"
INSIGHTS = ROOT / "data" / "insights"
GUIDANCE_DIR = ROOT / "config" / "guidance"

def run(cmd, tag=None):
    try:
        p = subprocess.run(cmd, capture_output=True, text=True)
        blob = []
        if tag: blob.append(f"[{tag}] cmd: {' '.join(cmd)}")
        if p.stdout: blob.append(p.stdout)
        if p.stderr: blob.append("::stderr::\n" + p.stderr)
        return p.returncode, "\n".join(blob).strip()
    except Exception as e:
        return -1, f"[EXC] {' '.join(cmd)} -> {e}"

def file_sha(path: pathlib.Path) -> str:
    import hashlib
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(1<<20), b""):
            h.update(chunk)
    return h.hexdigest()

def tidy_tmp(retain_candidates: bool = True, purge_days: int = 7):
    ARCHIVE.mkdir(parents=True, exist_ok=True)
    cand_dir = ARCHIVE / "candidates"
    cand_dir.mkdir(parents=True, exist_ok=True)
    now = time.time()
    if TMP.exists():
        for f in TMP.iterdir():
            if f.is_dir():
                if f.name in ("feedback","archive","prep_next"):
                    continue
            if ".bak." in f.name or ".reject." in f.name:
                try: shutil.move(str(f), str(ARCHIVE / f.name))
                except: pass
                continue
            if f.suffix in (".py",".yaml") and f.name != "last_summary.txt":
                try:
                    if retain_candidates:
                        shutil.copy2(str(f), str(cand_dir / f.name))
                    else:
                        shutil.move(str(f), str(cand_dir / f.name))
                except: pass
    for f in ARCHIVE.glob("**/*"):
        if f.is_file():
            age_days = (now - f.stat().st_mtime) / 86400.0
            if age_days > purge_days and f.suffix.lower() != ".zip":
                try: f.unlink()
                except: pass

def pack_zip(label: str, extras: dict[str,str], supervisor_log_text: str) -> pathlib.Path:
    FEEDBACK.mkdir(parents=True, exist_ok=True)
    ts = time.strftime("%Y%m%d_%H%M%S")
    pack_name = FEEDBACK / f"pack_{label}_{ts}.zip"
    # write supervisor log (even in emergency)
    sup_path = TMP / "supervisor_log.txt"
    sup_path.parent.mkdir(parents=True, exist_ok=True)
    sup_path.write_text(supervisor_log_text or "", encoding="utf-8")

    with zipfile.ZipFile(pack_name, "w", zipfile.ZIP_DEFLATED) as z:
        # insights
        if INSIGHTS.exists():
            for f in INSIGHTS.glob("*"):
                try: z.write(f, f"insights/{f.name}")
                except: pass
        # guidance
        if GUIDANCE_DIR.exists():
            for f in GUIDANCE_DIR.glob("*.yaml"):
                try: z.write(f, f"guidance/{f.name}")
                except: pass
        # extras provided (skip internal keys)
        for name, path in (extras or {}).items():
            if not name or name.startswith("_"): 
                continue
            if path and os.path.exists(path):
                try: z.write(path, name)
                except: pass
        # backups/rejects near replaced file
        rep_dir = (extras or {}).get("_replaced_dir")
        rep_base = (extras or {}).get("_replaced_base")
        if rep_dir and rep_base and os.path.isdir(rep_dir):
            for fn in os.listdir(rep_dir):
                if fn.startswith(rep_base + ".bak.") or fn.startswith(rep_base + ".reject."):
                    try: z.write(os.path.join(rep_dir, fn), f"replaced_artifacts/{fn}")
                    except: pass
        # include supervisor log last
        try: z.write(sup_path, "supervisor_log.txt")
        except: pass
    return pack_name

def main():
    # Args optional; remain None-safe
    target = None; newf = None; label = "apply_pack"
    if len(sys.argv) >= 3:
        import pathlib as _p
        target = _p.Path(sys.argv[1])
        newf   = _p.Path(sys.argv[2])
        label  = sys.argv[3] if len(sys.argv) >= 4 else (target.stem if target else "apply_pack")

    sup = []

    def log(tag, text):
        sup.append(f"--- {tag} ---\n{text}")

    try:
        # Step awareness
        rc, out = run([sys.executable, "tools/show_next_step.py"], tag="show_next_step")
        log("show_next_step", out)
        (TMP / "current_step.txt").write_text(out or "", encoding="utf-8")

        # Inventory (pre)
        rc, out = run([sys.executable, "tools/deep_inventory.py"], tag="deep_inventory_pre")
        log("deep_inventory_pre", out)

        # Reflection Gate (optional)
        if (ROOT / "tools" / "reflection_gate.py").exists():
            rc, out = run([sys.executable, "tools/reflection_gate.py"], tag="reflection_gate")
            log("reflection_gate", out)

        # Guarded replace (optional)
        replaced_ok = False
        safe_out = "[SKIP] Replace not attempted."
        if target and newf:
            if not target.exists():
                safe_out = f"[ABORT] Target missing: {target}"
            elif not newf.exists():
                safe_out = f"[ABORT] New file missing: {newf}"
            else:
                expected = file_sha(target)
                rc, out = run([sys.executable, "tools/safe_replace.py",
                              "--path", str(target),
                              "--expected-sha", expected,
                              "--new", str(newf)], tag="safe_replace")
                safe_out = out
                replaced_ok = (rc == 0)
        print(safe_out)
        log("safe_replace", safe_out)

        # Inventory (post)
        rc, out = run([sys.executable, "tools/deep_inventory.py"], tag="deep_inventory_post")
        log("deep_inventory_post", out)

        # Summary (best-effort)
        rc, out = run([sys.executable, "tools/make_summary.py"], tag="make_summary")
        log("make_summary", out)
        summary_file = ROOT / "last_summary.txt"
        if not summary_file.exists():
            summary_file = ROOT / "tmp" / "last_summary.txt"

        # Prep next (best-effort)
        prep_includes = {}
        try:
            first = sup[0] if sup else ""
            prep_dir = TMP / "prep_next"
            prep_dir.mkdir(exist_ok=True)
            readme = (prep_dir / "README_next.txt")
            readme.write_text("Scaffolding holder for NEXT step.\n", encoding="utf-8")
            prep_includes["prep_next/README_next.txt"] = str(readme)
        except Exception as e:
            log("prep_next", f"[ERROR] {e}")

        # Tidy tmp
        tidy_tmp(retain_candidates=True)

        # Build extras for pack safely
        extras = {
            "current_step.txt": str(TMP / "current_step.txt"),
            "last_summary.txt": str(summary_file) if summary_file.exists() else None,
            # Only include candidate if we actually had one
        }
        if newf is not None and os.path.exists(str(newf)):
            extras[f"candidate/{os.path.basename(str(newf))}"] = str(newf)
        if target is not None:
            extras["_replaced_dir"]  = str(target.parent)
            extras["_replaced_base"] = target.name

        pack = pack_zip(label, extras, "\n\n".join(sup))
        msg = f"[APPLY+PACK {'OK' if replaced_ok else 'WARN'}] {pack}"
        print(msg)
        if pyperclip:
            try: pyperclip.copy(msg)
            except: pass
        sys.exit(0 if replaced_ok else 1)

    except Exception:
        # EMERGENCY pack
        err = traceback.format_exc()
        sup.append("--- EMERGENCY EXCEPTION ---\n" + err)
        pack = pack_zip("emergency", {
            "current_step.txt": str(TMP / "current_step.txt") if (TMP / "current_step.txt").exists() else None
        }, "\n\n".join(sup))
        print(f"[APPLY+PACK EMERGENCY] {pack}")
        if pyperclip:
            try: pyperclip.copy(f"[APPLY+PACK EMERGENCY] {pack}")
            except: pass
        sys.exit(2)

if __name__ == "__main__":
    main()
